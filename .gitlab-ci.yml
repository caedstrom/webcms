# This file is the initial entrypoint for GitLab CI/CD builds. It serves primarily as a
# "driver" for other jobs: instead of executing build logic itself, it identifies which
# jobs pertain to the branch being built and dispatches those. (The exception to this is
# the Drush logic, which is encapsulated by a Node.js script in the ci/ directory.)

stages:
  # Applications of the infrastructure Terraform module. This has to occur first because,
  # without it, Docker builds could attempt to push to empty ECR repositories.
  - infrastructure
  
  - infrastructure_init
  - infrastructure_validate
  - infrastructure_plan
  - infrastructure_apply

  # Docker builds
  - build

  # Applications of the webcms Terraform module
  - deploy

  # Drush
  - update

# Our GitLab runner environment is Docker-based, so we apply this tag to every step.
default:
  tags:
    - docker

# Define this variable once here and allow it to cascade down into jobs and child
# pipelines.
variables:
  WEBCMS_IMAGE_TAG: $CI_COMMIT_REF_SLUG-$CI_COMMIT_SHA

#region Templates

# This is the base template for all jobs in this pipeline.
.terraform:
  image:
    name: registry.gitlab.com/gitlab-org/terraform-images/releases/0.14:latest
    entrypoint: ['']

  variables:
    # Derive the root from the project directory and module name
    TF_ROOT: $CI_PROJECT_DIR/terraform/$TF_MODULE

    # Tell Terraform we are running in automation and should fail if it finds missing inputs
    # instead of attempting to read from the console.
    TF_INPUT: '0'
    TF_IN_AUTOMATION: '1'

    # Proxy input variables from our convention to variables recognizable by Terraform. We
    # can do this unconditionally because Terraform only inspects the environment when it
    # sees a declaration, sparing us from spurious warnings about values for undeclared
    # variables.
    TF_VAR_environment: ${WEBCMS_ENVIRONMENT}
    TF_VAR_site: ${WEBCMS_SITE}
    TF_VAR_lang: ${WEBCMS_LANG}
    TF_VAR_image_tag: ${WEBCMS_IMAGE_TAG}
    TF_VAR_aws_region: ${AWS_REGION}

  # Use a granular cache for Terraform providers, bucketing by both module and branch.
  cache:
    key: tf-${TF_MODULE}-${CI_COMMIT_REF_SLUG}
    paths:
      - ${TF_ROOT}/.terraform

  # Every job begins execution in the module's root directory with:
  # 1. An empty http backend configuration to be filled in by the gitlab-terraform helper,
  #    and
  # 2. A copy of the GitLab-injected TERRAFORM_TFVARS file variable. (This variable is a
  #    reference to a path in a temporary directory, so we copy it in order to allow
  #    Terraform to see it automatically.)
  #
  # We do not explicitly invoke `gitlab-terraform init` because the helper script does
  # this automatically as needed.
  before_script:
    - cd $TF_ROOT
    - echo 'terraform { backend "http" {} }' >backend.tf
    - cp "$TERRAFORM_TFVARS" terraform.tfvars

init:
  extends: .terraform
  stage: infrastructure_init

  script:
    - gitlab-terraform init

validate:
  extends: .terraform
  stage: infrastructure_validate

  script:
    - gitlab-terraform validate

# Perform a plan, uploading the plan files as GitLab artifacts.
plan:
  extends: .terraform
  stage: infrastructure_plan

  script:
    - gitlab-terraform plan
    - gitlab-terraform plan-json

  artifacts:
    name: plan
    paths:
      - $TF_ROOT/plan.cache
    reports:
      terraform: $TF_ROOT/plan.json

apply:
  extends: .terraform
  stage: infrastructure_apply

  # Download the plan files from the previous step.
  dependencies: [plan]

  script:
    - gitlab-terraform apply

  # We use GitLab's rules to limit when we block the application of a Terraform module.
  #
  # There are three rules:
  # 1. We require approval of the infrastructure module on its tracking branches (main and
  #    live).
  # 2. We permit automatic application of the webcms module, since it only updates a
  #    limited subset of ECS resources.
  # 3. Any other attempt to apply a Terraform plan is explicitly denied. This is provided
  #    as a safety net to keep misconfigured trigger jobs from accidentally clobbering
  #    live AWS resources.
  #
  # NB. GitLab uses a "first match wins" order of rule evaluation, which is why the third
  # rule does not have an `if:` condition limiting when it applies.
  rules:
    - if: >-
        $TF_MODULE == "infrastructure" &&
        ($CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "live")
      when: manual

    - if: >-
        $TF_MODULE == "webcms" &&
        ($CI_COMMIT_BRANCH == "integration" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "live")
      when: on_success

    - when: never



# Jobs defined in this section are template jobs (the leading dot tells GitLab to
# unconditionally ignore them when assembling a pipeline graph). The templates are named
# after the stage in which they execute, and serve as central locations for the
# boilerplate that each step needs to execute. The pipelines here are not complicated in
# the sense that there are a large _variety_ of steps involved; there is instead a large
# _number_ of steps, and cutting down on repetitious information helps avoid visual noise
# when reading this file.
#
# Each template is guaranteed to include the following items:
# 1. The stage in which the job should execute
# 2. The actual job logic itself (which pipeline to trigger or which script to execute).
#
# While some templates may have additional supporting definitions/conveniences, extensions
# MUST provide the following:
# 1. Which environment ($WEBCMS_ENVIRONMENT) this job applies to.
# 2. Where applicable, the site ($WEBCMS_SITE) and language ($WEBCMS_LANG) this job
#    applies to.
# 3. Any throttling/parallelism limitations (e.g., the resource_group: keyword).
# 4. Branch limitations.
#
# Some of this information could be automatically derived in the template, but this can
# very easily cause confusion, so we instead mandate that jobs that extend a template
# repeat the logic to provide clarity on when a job is executed by GitLab, and how
# parallel it is permitted to be.

# Infrastructure jobs apply the Terraform module of the same name. They always trigger
# the Terraform pipeline with $TF_MODULE set to the same value.
.infrastructure:
  stage: infrastructure

  trigger:
    include: .gitlab/terraform.yml
    strategy: depend

  variables:
    TF_MODULE: infrastructure

# Build jobs perform a Kaniko build. We create a child pipeline due to the number of
# images that are built (at least Drupal, nginx, and Drush).
.build:
  stage: build

  trigger:
    include: .gitlab/docker.yml
    strategy: depend

# Deploy jobs use Terraform to create/update the ECS task definitions and services that
# make up the Drupal WebCMS.
.deploy:
  stage: deploy

  trigger:
    include: .gitlab/terraform.yml
    strategy: depend

  variables:
    TF_MODULE: webcms

# Update jobs invoke Drush to perform the necessary maintenance commands (drush updb,
# drush cim) against the freshly-updated cluster. See the ci/ directory for more
# information on the update script.
.update:
  stage: update

  # Run inside a Node.js image. At the time of writing, Node.js 14 is the latest stable
  # version.
  image:
    name: node:14-alpine
    entrypoint: ['']

  # See the comments below for why the npm cache is redirected.
  script:
    - cd $CI_PROJECT_DIR/ci
    - npm ci --production --prefer-offline --cache .npm
    - node drush.js

  # Per https://docs.gitlab.com/ee/ci/caching/#cache-nodejs-dependencies, GitLab doesn't
  # support caching outside the project directory, so we have to relocate the .npm cache
  # directory inside the project root.
  cache:
    key: npm-drush
    paths: 
        - ci/.npm

#endregion

#region Preproduction

# Jobs in this region affect the preproduction environment. Per convention, the
# preproduction environment encompasses two sites: development and staging, hence
# the subregions below the infrastructure step.

# Preproduction infrastructure builds are triggered only by the 'main' branch.
infrastructure:preproduction:
  extends: .infrastructure
  only:
    refs:
      - main

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    TF_STATE_NAME: dev

  script:
    - echo "do nothing"

  # The resource_group option tells GitLab to prevent overlapping runs, regardless of how
  # many builds were triggered. (Without this, Terraform would raise an error due to
  # finding a lock already present.)
  #
  # The environment here is used primarily to serve as a scoping mechanism for the
  # TF_VAR_* variables; without this, different environments would clobber each other's
  # variables depending on what was defined. We use the "infra/" prefix to distinguish
  # infrastructure-level GitLab environments and site- and language-level GitLab
  # environments.
  #
  # Note that this means that while this repository distinguishes between environments,
  # sites, and languages, this CI file tells GitLab to call any combination of the three
  # an "environment". Be aware of this when reading that key in these definitions.
  resource_group: infra/preproduction
  environment:
    name: infra/preproduction
    deployment_tier: staging

#region Development

# Jobs that apply to the dev site, for both English and Spanish (when differentiated).

# Build all of the dev images with Kaniko. Unlike most of the other jobs here, we do not
# need to define resource_group: since image builds can safely overlap (the tags are unique
# by branch and commit), nor do we need to define environment: because the image builds
# do not have inputs that should be tracked outside of the repository.
build:dev:
  extends: .build
  only:
    refs:
      - integration

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: dev

# Deploy both English and Spanish to dev. We use the parallel:matrix: feature to loop over
# both language codes.
deploy:dev:
  extends: .deploy
  only:
    refs:
      - integration

#   parallel:
#     matrix:
#       - WEBCMS_LANG: [en, es]

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: dev
    TF_STATE_NAME: dev-webcms-$WEBCMS_LANG

  # As mentioned in the comments on the infrastructure:preproduction job, we use a
  # resource group to prevent overlapping Terraform runs. The environment names here are
  # prefixed with "site/" to indicate that they're for the Drupal site instead of
  # infrastructure.
  resource_group: site/dev-$WEBCMS_LANG
  environment:
    name: site/dev-$WEBCMS_LANG
    deployment_tier: development

# Deploy both English and Spanish, using the same parallel:matrix: feature as above.
update:dev:
  extends: .update
  only:
    refs:
      - integration

#   parallel:
#     matrix:
#       - WEBCMS_LANG: [en, es]

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: dev

  # Note that while we want to prevent overlapping Drush runs, we don't also include an
  # environment here because, like the Docker image builds, there are no inputs outside
  # of the provided $WEBCMS_* variables.
  resource_group: drush/dev-$WEBCMS_LANG

#endregion

#region Staging

# The jobs here follow the same pattern as the development jobs, so instead of repeating
# the comments here, we note the differences:
#
# 1. Jobs are limited to the 'main' branch instead of 'integration'.
# 2. The site name is 'stage' instead of 'dev'.

build:stage:
  extends: .build
  only:
    refs:
      - main

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: stage

deploy:stage:
  extends: .deploy
  only:
    refs:
      - main

#   parallel:
#     matrix:
#       - WEBCMS_LANG: [en, es]

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: stage
    TF_STATE_NAME: stage-webcms-$WEBCMS_LANG

  resource_group: site/stage-$WEBCMS_LANG
  environment:
    name: site/stage-$WEBCMS_LANG
    deployment_tier: staging

update:stage:
  extends: .update
  only:
    refs:
      - main

  variables:
    WEBCMS_ENVIRONMENT: preproduction
    WEBCMS_SITE: stage

  resource_group: drush/stage-$WEBCMS_LANG

#endregion

#endregion
